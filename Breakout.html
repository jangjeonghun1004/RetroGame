<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Brick Breaker</title>
    <!-- 구글 폰트: 레트로 픽셀 폰트 -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #050505;
            color: #0f0;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* 게임 컨테이너 (캔버스 감싸기) */
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            border: 4px solid #333;
            background-color: #000;
            max-width: 100%;
            max-height: 100%;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        /* CRT 모니터 스캔라인 효과 */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* UI 오버레이 (시작 화면, 게임 오버 등) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            text-align: center;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 30px;
            color: #0ff;
            text-shadow: 4px 4px #f0f;
            line-height: 1.5;
        }

        /* 통계 정보 스타일 개선 */
        .stats-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            padding: 0 20px; /* 좌우 여백 확보 */
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            flex-direction: column; /* 수직 정렬 */
            align-items: center;    /* 중앙 정렬 */
            justify-content: center;
            
            background-color: rgba(0, 20, 0, 0.6); /* 반투명 배경 */
            border: 2px solid #333; /* 테두리 */
            padding: 15px 10px;
            
            width: 45%; /* 한 줄에 2개씩 배치 */
            min-width: 130px;
            
            color: #fff;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
        }

        .stat-label {
            color: #888;
            font-size: 10px;
            margin-bottom: 8px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 16px;
        }

        .highlight {
            color: #ff0;
        }
        
        .max-stat {
            color: #0ff; /* 최고 기록은 다른 색상 */
        }

        button {
            margin-top: 30px;
            background: transparent;
            color: #0f0;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 15px 20px;
            border: 4px solid #0f0;
            cursor: pointer;
            text-transform: uppercase;
            animation: blink 1s infinite;
        }

        button:hover {
            background: #0f0;
            color: #000;
            animation: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* 모바일용 컨트롤 안내 */
        .mobile-controls {
            display: none;
            margin-top: 20px;
            font-size: 10px;
            color: #888;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        
        <div id="ui-layer">
            <h1>RETRO<br>BREAKOUT</h1>
            
            <div class="stats-container">
                <!-- 현재/마지막 게임 정보 -->
                <div class="stat-item">
                    <span class="stat-label">LAST SCORE</span>
                    <span id="last-score-display" class="stat-value highlight">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">LAST LEVEL</span>
                    <span id="last-level-display" class="stat-value highlight">1</span>
                </div>
                
                <!-- 최고 기록 정보 -->
                <div class="stat-item">
                    <span class="stat-label">HIGH SCORE</span>
                    <span id="highscore-display" class="stat-value max-stat">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">MAX LEVEL</span>
                    <span id="maxlevel-display" class="stat-value max-stat">1</span>
                </div>
            </div>

            <div class="mobile-controls">Touch & Drag to Move</div>
            <button id="start-btn">INSERT COIN</button>
        </div>
    </div>

    <script>
        /**
         * 게임 설정 및 상수
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const startBtn = document.getElementById('start-btn');
        
        // UI 요소 (시작 화면용)
        const lastScoreDisplay = document.getElementById('last-score-display');
        const lastLevelDisplay = document.getElementById('last-level-display');
        const highScoreDisplay = document.getElementById('highscore-display');
        const maxLevelDisplay = document.getElementById('maxlevel-display');
        const titleText = uiLayer.querySelector('h1');

        // 로컬 스토리지 키 정의
        const STORAGE_KEYS = {
            HIGH_SCORE: 'retroBreakout_highScore',
            MAX_LEVEL: 'retroBreakout_maxLevel',
            LAST_SCORE: 'retroBreakout_lastScore',
            LAST_LEVEL: 'retroBreakout_lastLevel'
        };

        // 데이터 로드
        let highScore = parseInt(localStorage.getItem(STORAGE_KEYS.HIGH_SCORE)) || 0;
        let maxLevel = parseInt(localStorage.getItem(STORAGE_KEYS.MAX_LEVEL)) || 1;
        let lastScore = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_SCORE)) || 0;
        let lastLevel = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_LEVEL)) || 1;

        // UI 업데이트 함수
        function updateStatsUI() {
            highScoreDisplay.innerText = highScore;
            maxLevelDisplay.innerText = maxLevel;
            lastScoreDisplay.innerText = lastScore;
            lastLevelDisplay.innerText = lastLevel;
        }
        
        // 초기 UI 갱신
        updateStatsUI();


        // 반응형 캔버스 크기 설정
        let GAME_WIDTH = 600;
        let GAME_HEIGHT = 800;
        
        function resizeCanvas() {
            const maxWidth = window.innerWidth - 20;
            const maxHeight = window.innerHeight - 20;
            const aspect = 3 / 4;
            let width = maxWidth;
            let height = width / aspect;

            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspect;
            }

            canvas.width = width;
            canvas.height = height;
            
            scaleX = canvas.width / GAME_WIDTH;
            scaleY = canvas.height / GAME_HEIGHT;
        }

        let scaleX = 1;
        let scaleY = 1;

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        /**
         * 오디오 시스템 (Web Audio API - 칩튠 사운드)
         */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'paddle') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'brick') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'wall') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'over') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'goodItem') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'badItem') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(150, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'laser') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'barrier') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'levelup') { 
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            }
        }

        /**
         * 게임 객체 클래스
         */
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.speedX = Math.random() * 6 - 3;
                this.speedY = Math.random() * 6 - 3;
                this.life = 1.0; 
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 0.02;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.size * scaleX, this.size * scaleX);
                ctx.globalAlpha = 1.0;
            }
        }

        // 아이템 클래스
        class Item {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 24;
                this.dy = 3;
                
                const types = [
                    'wide', 'narrow', 'slow', 'fast', 
                    'multi', 'barrier', 'giant', 'tiny', 'power', 'laser'
                ];
                this.type = types[Math.floor(Math.random() * types.length)];
                
                switch(this.type) {
                    case 'wide': this.color = '#0f0'; this.symbol = 'W'; break;
                    case 'narrow': this.color = '#f00'; this.symbol = 'N'; break;
                    case 'slow': this.color = '#00f'; this.symbol = 'S'; break;
                    case 'fast': this.color = '#f90'; this.symbol = 'F'; break;
                    case 'multi': this.color = '#0ff'; this.symbol = 'M'; break;
                    case 'barrier': this.color = '#a0f'; this.symbol = 'B'; break;
                    case 'giant': this.color = '#f0f'; this.symbol = 'G'; break;
                    case 'tiny': this.color = '#800'; this.symbol = 'T'; break;
                    case 'power': this.color = '#ff0'; this.symbol = 'P'; break;
                    case 'laser': this.color = '#fff'; this.symbol = 'L'; break;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
                
                ctx.fillStyle = '#fff';
                ctx.font = `${12 * scaleX}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, (this.x + this.width/2) * scaleX, (this.y + this.height/2) * scaleY);
            }

            update() {
                this.y += this.dy;
            }
        }

        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 10;
                this.dy = -10;
                this.active = true;
            }
            
            draw(ctx) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
            }

            update() {
                this.y += this.dy;
                if(this.y < 0) this.active = false;
            }
        }

        class Ball {
            constructor(x, y, dx, dy) {
                this.defaultRadius = 8;
                this.radius = this.defaultRadius;
                this.x = x || GAME_WIDTH / 2;
                this.y = y || GAME_HEIGHT - 50;
                
                const baseSpeed = 5 + (level - 1) * 0.5;
                
                this.dx = dx || baseSpeed * (Math.random() < 0.5 ? 1 : -1);
                this.dy = dy || -baseSpeed;
                
                this.active = (dx !== undefined); 
                this.powerMode = false; 
            }
            
            reset() {
                this.x = paddle.x + paddle.width / 2;
                this.y = GAME_HEIGHT - 50;
                const baseSpeed = 5 + (level - 1) * 0.5;
                this.dx = baseSpeed * (Math.random() < 0.5 ? 1 : -1);
                this.dy = -baseSpeed;
                
                this.active = false;
                this.radius = this.defaultRadius;
                this.powerMode = false;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.fillStyle = this.powerMode ? '#ff0' : '#fff';
                if (this.powerMode) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff0';
                }
                
                ctx.fillRect(
                    (this.x - this.radius) * scaleX, 
                    (this.y - this.radius) * scaleY, 
                    (this.radius * 2) * scaleX, 
                    (this.radius * 2) * scaleX
                );
                ctx.shadowBlur = 0;
                ctx.closePath();
            }

            update() {
                if (!this.active) {
                    this.x = paddle.x + paddle.width / 2;
                    this.y = paddle.y - this.radius - 1;
                    return;
                }

                this.x += this.dx;
                this.y += this.dy;

                if (this.x + this.radius > GAME_WIDTH || this.x - this.radius < 0) {
                    this.dx = -this.dx;
                    playSound('wall');
                }
                if (this.y - this.radius < 0) {
                    this.dy = -this.dy;
                    playSound('wall');
                }
            }
            
            changeSpeed(multiplier) {
                const currentSpeed = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
                const newSpeed = currentSpeed * multiplier;
                if (newSpeed < 3 || newSpeed > 12 + level) return;
                const ratio = newSpeed / currentSpeed;
                this.dx *= ratio;
                this.dy *= ratio;
            }
        }

        class Paddle {
            constructor() {
                this.defaultWidth = Math.max(100 - (level - 1) * 5, 60);
                this.width = this.defaultWidth;
                this.height = 15;
                this.x = GAME_WIDTH / 2 - this.width / 2;
                this.y = GAME_HEIGHT - 40;
                this.speed = 8;
                this.dx = 0;
                
                this.laserActive = false;
                this.laserTimer = 0;
            }

            draw(ctx) {
                ctx.fillStyle = this.laserActive ? '#f0f' : '#0ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.laserActive ? '#f0f' : '#0ff';
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
                
                if(this.laserActive) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x * scaleX, this.y * scaleY, 5 * scaleX, -5 * scaleY);
                    ctx.fillRect((this.x + this.width - 5) * scaleX, this.y * scaleY, 5 * scaleX, -5 * scaleY);
                }
                ctx.shadowBlur = 0;
            }

            update() {
                this.x += this.dx;
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > GAME_WIDTH) this.x = GAME_WIDTH - this.width;

                if(this.laserActive && gameRunning && ballStarted) {
                    this.laserTimer++;
                    if(this.laserTimer > 40) { 
                        bullets.push(new Bullet(this.x, this.y));
                        bullets.push(new Bullet(this.x + this.width - 5, this.y));
                        this.laserTimer = 0;
                        playSound('laser');
                    }
                }
            }
            
            changeWidth(amount) {
                this.width += amount;
                if (this.width < 40) this.width = 40;
                if (this.width > 250) this.width = 250;
            }
        }

        class Brick {
            constructor(x, y, c) {
                this.x = x;
                this.y = y;
                this.c = c;
                this.width = 0;
                this.height = 25;
                this.status = 1;
            }
            
            draw(ctx) {
                if (this.status === 1) {
                    ctx.fillStyle = brickColors[this.c % brickColors.length];
                    ctx.fillRect(
                        (this.x + 2) * scaleX, 
                        (this.y + 2) * scaleY, 
                        (this.width - 4) * scaleX, 
                        (this.height - 4) * scaleY
                    );
                }
            }
        }

        /**
         * 게임 상태 관리
         */
        let paddle;
        let balls = [];
        let bullets = [];
        let bricks = [];
        let particles = [];
        let items = [];
        
        let score = 0;
        let level = 1; 
        
        let gameRunning = false;
        let animationId;
        let ballStarted = false;
        
        let barrierActive = false;
        let levelUpMsgTimer = 0; 

        let rightPressed = false;
        let leftPressed = false;
        
        let brickColors = [];

        function getLevelColors(lvl) {
            const themes = [
                ['#f00', '#f90', '#ff0', '#0f0', '#00f', '#f0f'], 
                ['#0ff', '#00f', '#50f', '#a0f', '#fff', '#0aa'], 
                ['#f00', '#d00', '#f60', '#fa0', '#fff', '#800'], 
                ['#0f0', '#5f5', '#080', '#cfc', '#050', '#afa'], 
                ['#f0f', '#ff0', '#0ff', '#fff', '#f00', '#00f'], 
                ['#fff', '#aaa', '#555', '#222', '#f00', '#888']  
            ];
            
            if (lvl <= themes.length) {
                return themes[lvl - 1];
            } else {
                let randomTheme = [];
                let baseHue = Math.random() * 360;
                for(let i=0; i<6; i++) {
                    randomTheme.push(`hsl(${(baseHue + i * 40) % 360}, 100%, 50%)`);
                }
                return randomTheme;
            }
        }

        function initBricks() {
            bricks = [];
            const rows = Math.min(6 + Math.floor((level - 1) / 2), 10);
            const cols = 8;
            const padding = 10;
            const offsetTop = 60;
            const offsetLeft = 35;
            
            const brickWidth = (GAME_WIDTH - (offsetLeft * 2)) / cols;

            for(let c=0; c<cols; c++) {
                for(let r=0; r<rows; r++) {
                    let b = new Brick(0, 0, r);
                    b.x = (c * brickWidth) + offsetLeft;
                    b.y = (r * (b.height + padding)) + offsetTop;
                    b.width = brickWidth;
                    bricks.push(b);
                }
            }
        }

        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);
        
        function movePaddleByTouch(clientX) {
            const rect = canvas.getBoundingClientRect();
            const relativeX = clientX - rect.left;
            const gameX = relativeX / scaleX;
            paddle.x = gameX - paddle.width / 2;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;
        }

        canvas.addEventListener('mousemove', (e) => {
            if(gameRunning) movePaddleByTouch(e.clientX);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if(gameRunning) {
                e.preventDefault();
                movePaddleByTouch(e.touches[0].clientX);
            }
        }, {passive: false});

        canvas.addEventListener('click', () => {
            if(gameRunning && !ballStarted) {
                balls.forEach(b => b.active = true);
                ballStarted = true;
            }
        });

        function keyDownHandler(e) {
            if(e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
            else if(e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
            else if(e.code === 'Space' && gameRunning && !ballStarted) {
                balls.forEach(b => b.active = true);
                ballStarted = true;
            }
        }

        function keyUpHandler(e) {
            if(e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
            else if(e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
        }

        function spawnItem(x, y) {
            if (Math.random() < 0.25) {
                items.push(new Item(x, y));
            }
        }

        function destroyBrick(b) {
            b.status = 0;
            score += 10;
            // 인게임 점수는 캔버스에만 그림. DOM 업데이트 X
            playSound('brick');
            
            for(let k=0; k<6; k++) {
                particles.push(new Particle(b.x + b.width/2, b.y + b.height/2, brickColors[b.c % brickColors.length]));
            }
            spawnItem(b.x + b.width/2 - 12, b.y);
        }

        function nextLevel() {
            level++;
            playSound('levelup');
            
            // 최고 레벨 업데이트 체크
            if(level > maxLevel) {
                maxLevel = level;
                localStorage.setItem(STORAGE_KEYS.MAX_LEVEL, maxLevel);
            }

            brickColors = getLevelColors(level);
            
            balls = [new Ball()];
            ballStarted = false;
            bullets = [];
            items = [];
            particles = [];
            barrierActive = false;
            paddle = new Paddle();
            initBricks();
            levelUpMsgTimer = 120; 
        }

        function collisionDetection() {
            let activeBricks = bricks.filter(b => b.status === 1).length;
            if(activeBricks === 0) {
                nextLevel(); 
            }

            balls.forEach(ball => {
                if(!ball.active) return;

                for(let i=0; i<bricks.length; i++) {
                    let b = bricks[i];
                    if(b.status === 1) {
                        if(ball.x > b.x && ball.x < b.x + b.width && ball.y > b.y && ball.y < b.y + b.height) {
                            if (!ball.powerMode) {
                                ball.dy = -ball.dy;
                            }
                            destroyBrick(b);
                        }
                    }
                }

                if (ball.y + ball.radius >= paddle.y && 
                    ball.y - ball.radius <= paddle.y + paddle.height &&
                    ball.x >= paddle.x && 
                    ball.x <= paddle.x + paddle.width) {
                    
                    if (ball.dy > 0) {
                        ball.dy = -ball.dy;
                        const hitPoint = ball.x - (paddle.x + paddle.width / 2);
                        ball.dx = hitPoint * 0.15; 
                        if(Math.abs(ball.dx) < 2) ball.dx = (ball.dx < 0 ? -2 : 2);
                        playSound('paddle');
                    }
                }

                if (barrierActive && ball.y + ball.radius > GAME_HEIGHT - 10) {
                    ball.dy = -Math.abs(ball.dy); 
                    barrierActive = false; 
                    playSound('barrier');
                }
            });

            bullets.forEach(bullet => {
                if(!bullet.active) return;
                for(let i=0; i<bricks.length; i++) {
                    let b = bricks[i];
                    if(b.status === 1) {
                        if(bullet.x > b.x && bullet.x < b.x + b.width && bullet.y > b.y && bullet.y < b.y + b.height) {
                            bullet.active = false;
                            destroyBrick(b);
                            break; 
                        }
                    }
                }
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 캔버스 내 HUD (인게임)
            ctx.fillStyle = '#fff';
            ctx.font = `${20 * scaleX}px "Press Start 2P"`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`SCORE: ${score}`, 20 * scaleX, 20 * scaleY);
            
            ctx.textAlign = 'right';
            ctx.fillText(`LVL: ${level}`, GAME_WIDTH * scaleX - 20, 20 * scaleY);

            if(levelUpMsgTimer > 0) {
                ctx.fillStyle = `rgba(255, 255, 0, ${levelUpMsgTimer / 60})`; 
                ctx.font = `${40 * scaleX}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`LEVEL ${level}`, (GAME_WIDTH/2) * scaleX, (GAME_HEIGHT/2) * scaleY);
                levelUpMsgTimer--;
            }

            if(rightPressed) paddle.dx = paddle.speed;
            else if(leftPressed) paddle.dx = -paddle.speed;
            else paddle.dx = 0;
            paddle.update();
            paddle.draw(ctx);
            
            for(let i = balls.length -1; i >= 0; i--) {
                let b = balls[i];
                b.update();
                b.draw(ctx);
                if(b.y - b.radius > GAME_HEIGHT) {
                    balls.splice(i, 1);
                }
            }

            if(balls.length === 0 && gameRunning) {
                gameOver();
            }

            for(let i = bullets.length -1; i >= 0; i--) {
                bullets[i].update();
                bullets[i].draw(ctx);
                if(!bullets[i].active) bullets.splice(i, 1);
            }

            bricks.forEach(brick => brick.draw(ctx));

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw(ctx);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            if(barrierActive) {
                ctx.fillStyle = '#a0f';
                ctx.globalAlpha = 0.5;
                ctx.fillRect(0, (GAME_HEIGHT - 10) * scaleY, GAME_WIDTH * scaleX, 10 * scaleY);
                ctx.globalAlpha = 1.0;
            }

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                item.update();
                item.draw(ctx);

                if (item.y > GAME_HEIGHT) {
                    items.splice(i, 1);
                    continue;
                }

                if (item.x < paddle.x + paddle.width &&
                    item.x + item.width > paddle.x &&
                    item.y < paddle.y + paddle.height &&
                    item.y + item.height > paddle.y) {
                    
                    applyItemEffect(item.type);
                    items.splice(i, 1);
                }
            }

            collisionDetection();

            if(gameRunning) {
                animationId = requestAnimationFrame(draw);
            }
        }

        function applyItemEffect(type) {
            let isBad = (type === 'narrow' || type === 'fast' || type === 'tiny');
            playSound(isBad ? 'badItem' : 'goodItem');

            switch(type) {
                case 'wide': paddle.changeWidth(30); break;
                case 'narrow': paddle.changeWidth(-30); break;
                case 'slow': balls.forEach(b => b.changeSpeed(0.8)); break;
                case 'fast': balls.forEach(b => b.changeSpeed(1.3)); break;
                
                case 'multi': 
                    let newBalls = [];
                    balls.forEach(b => {
                        newBalls.push(new Ball(b.x, b.y, b.dx - 2, b.dy));
                        newBalls.push(new Ball(b.x, b.y, b.dx + 2, b.dy));
                    });
                    balls = balls.concat(newBalls);
                    break;

                case 'barrier': barrierActive = true; break;
                case 'giant': balls.forEach(b => b.radius = 16); break;
                case 'tiny': balls.forEach(b => b.radius = 4); break;
                case 'power':
                    balls.forEach(b => b.powerMode = true);
                    setTimeout(() => {
                        balls.forEach(b => b.powerMode = false);
                    }, 5000);
                    break;
                case 'laser':
                    paddle.laserActive = true;
                    setTimeout(() => {
                        paddle.laserActive = false;
                    }, 8000); 
                    break;
            }
        }

        function startGame() {
            initAudio();
            uiLayer.style.display = 'none';
            score = 0;
            level = 1; 
            // 게임 시작 시 UI가 아닌 캔버스에 그릴 예정이므로 DOM 업데이트는 필요 없음
            
            brickColors = getLevelColors(level);
            
            paddle = new Paddle();
            balls = [new Ball()]; 
            bullets = [];
            items = [];
            barrierActive = false;
            initBricks();
            particles = [];
            ballStarted = false;
            
            gameRunning = true;
            draw();
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            playSound('over');
            
            // 데이터 저장 및 갱신
            lastScore = score;
            lastLevel = level;
            
            if (score > highScore) {
                highScore = score;
            }
            if (level > maxLevel) {
                maxLevel = level;
            }

            // 로컬 스토리지에 저장
            localStorage.setItem(STORAGE_KEYS.HIGH_SCORE, highScore);
            localStorage.setItem(STORAGE_KEYS.MAX_LEVEL, maxLevel);
            localStorage.setItem(STORAGE_KEYS.LAST_SCORE, lastScore);
            localStorage.setItem(STORAGE_KEYS.LAST_LEVEL, lastLevel);
            
            // UI 업데이트
            titleText.innerHTML = "GAME OVER";
            startBtn.innerText = "TRY AGAIN";
            updateStatsUI();
            
            uiLayer.style.display = 'flex';
        }

        startBtn.addEventListener('click', startGame);

    </script>
</body>
</html>