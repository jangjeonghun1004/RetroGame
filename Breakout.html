<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Brick Breaker Console</title>
    <!-- 구글 폰트 -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #222;
            color: #0f0;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        /* --- 콘솔 본체 디자인 --- */
        .console-body {
            background-color: #e0e0e0;
            width: 100%;
            max-width: 420px;
            height: 98vh;
            max-height: 850px;
            border-radius: 20px;
            padding: 15px;
            padding-bottom: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: 
                0 0 0 5px #d0d0d0,
                0 20px 50px rgba(0,0,0,0.5),
                inset 0 -5px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        /* --- 화면 영역 --- */
        .screen-bezel {
            background-color: #111;
            border-radius: 10px;
            padding: 10px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #000;
            border: 2px solid #333;
            overflow: hidden;
            border-radius: 4px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* --- UI 레이어 시스템 --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20;
            pointer-events: auto; /* 입력 필드 클릭 가능하게 */
            overflow: hidden; /* 내부 내용이 넘치지 않도록 */
        }

        .screen-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 중앙 정렬 */
            background: rgba(0, 0, 0, 0.85);
            text-align: center;
            padding: 10px; /* 내부 패딩 추가로 텍스트 잘림 방지 */
        }

        .screen-ui.active {
            display: flex;
        }

        h1 {
            font-size: 18px; /* 폰트 사이즈 약간 축소 */
            margin-bottom: 15px; /* 여백 축소 */
            color: #0ff;
            text-shadow: 3px 3px #f0f;
            line-height: 1.4;
        }

        h2 {
            font-size: 10px; /* 폰트 사이즈 축소 */
            color: #ff0;
            margin-bottom: 10px;
        }

        p {
            font-size: 10px;
            color: #fff;
            margin-bottom: 8px; /* 여백 축소 */
            line-height: 1.4;
        }

        /* 통계 박스 */
        .stats-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            width: 100%;
        }

        .stat-item {
            background-color: rgba(0, 20, 0, 0.6);
            border: 1px solid #0f0;
            padding: 8px; /* 패딩 축소 */
            width: 90px;
        }

        .stat-label { display: block; color: #888; font-size: 7px; margin-bottom: 3px; }
        .stat-value { font-size: 10px; color: #fff; }

        /* 버튼 스타일 */
        button {
            background: transparent;
            color: #0f0;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px; /* 버튼 폰트 축소 */
            padding: 8px 12px; /* 버튼 크기 축소 */
            border: 2px solid #0f0;
            cursor: pointer;
            margin-top: 8px;
            text-transform: uppercase;
        }
        
        button:hover { background: #0f0; color: #000; }
        button.blink { animation: blink 1s infinite; }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* 랭킹 리스트 스타일 */
        .ranking-list-container {
            width: 90%;
            margin-bottom: 15px;
            font-size: 8px; /* 폰트 사이즈 축소 */
            line-height: 1.6;
        }
        .rank-row {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dashed #333;
            padding: 4px 0; /* 패딩 축소 */
            align-items: center; 
        }
        /* 순위 아이콘 영역 (고정 너비) */
        .rank-rank { 
            color: #ff0; 
            width: 50px; /* 너비 조정 */
            text-align: left;
            font-size: 12px; /* 이모지 크기 조정 */
            text-shadow: 1px 1px #000; 
        }
        /* 이름 영역 */
        .rank-name { 
            color: #0ff; 
            text-align: center; 
            flex: 1; 
            font-size: 10px; 
        } 
        /* 점수 영역 */
        .rank-score { 
            color: #fff; 
            text-align: right; 
            font-size: 10px; 
            width: 60px; 
        }

        /* 이니셜 입력 필드 */
        input#initials-input {
            background: transparent;
            border: none;
            border-bottom: 3px solid #0f0;
            color: #ff0;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px; /* 입력창 크기 조정 */
            width: 100px;
            text-align: center;
            margin: 15px 0;
            text-transform: uppercase;
            outline: none;
        }

        /* --- 컨트롤러 영역 --- */
        .controls-area {
            flex: 0 0 auto; 
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto; 
            gap: 5px; 
            padding: 0 5px 5px 5px;
        }

        /* 십자키 */
        .d-pad-container { position: relative; width: 110px; height: 110px; justify-self: center; align-self: center; }
        .d-pad { position: relative; width: 100%; height: 100%; }
        .d-pad div { position: absolute; background: #333; border-radius: 4px; box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2), 2px 2px 5px rgba(0,0,0,0.3); cursor: pointer; }
        .d-pad div:active { background: #222; transform: scale(0.95); }
        .d-pad-h { top: 36px; left: 0; width: 110px; height: 38px; z-index: 1; }
        .d-pad-v { top: 0; left: 36px; width: 38px; height: 110px; z-index: 1; }
        .d-pad-center { top: 36px; left: 36px; width: 38px; height: 38px; background: radial-gradient(circle at 30% 30%, #444, #222); z-index: 2; border-radius: 50%; }
        .d-btn { position: absolute; z-index: 10; opacity: 0; cursor: pointer; }
        .btn-up { top: 0; left: 36px; width: 38px; height: 38px; }
        .btn-down { bottom: 0; left: 36px; width: 38px; height: 38px; }
        .btn-left { top: 36px; left: 0; width: 38px; height: 38px; }
        .btn-right { top: 36px; right: 0; width: 38px; height: 38px; }

        /* 액션 버튼 */
        .action-buttons { position: relative; width: 120px; height: 120px; justify-self: center; align-self: center; transform: rotate(-15deg); }
        .abxy-btn { position: absolute; width: 32px; height: 32px; border-radius: 50%; background: #333; color: rgba(255,255,255,0.8); display: flex; align-items: center; justify-content: center; font-family: 'Roboto', sans-serif; font-weight: bold; font-size: 13px; box-shadow: 0 3px 0 #111, 0 5px 5px rgba(0,0,0,0.3); cursor: pointer; transition: transform 0.1s, box-shadow 0.1s; }
        .abxy-btn:active { transform: translateY(3px); box-shadow: 0 0 0 #111, inset 0 2px 5px rgba(0,0,0,0.5); }
        .btn-x { top: 5px; left: 44px; color: #40a0ff; }
        .btn-y { top: 44px; left: 5px; color: #40ff40; }
        .btn-b { top: 44px; right: 5px; color: #ffd040; }
        .btn-a { bottom: 5px; left: 44px; color: #ff4040; }

        /* 기능 버튼 */
        .center-buttons { grid-column: 1 / -1; display: flex; justify-content: center; gap: 20px; margin: 5px 0; }
        .fn-btn-group { display: flex; flex-direction: column; align-items: center; gap: 3px; }
        .fn-btn { width: 45px; height: 12px; background: #555; border-radius: 8px; transform: rotate(-20deg); box-shadow: 0 2px 2px rgba(0,0,0,0.3); cursor: pointer; }
        .fn-btn:active { transform: rotate(-20deg) scale(0.95); background: #444; }
        .fn-label { font-family: 'Roboto', sans-serif; font-size: 7px; color: #888; font-weight: bold; text-transform: uppercase; }

        .mobile-controls { display: none; }
    </style>
</head>
<body>

    <div class="console-body">
        <div class="screen-bezel">
            <div id="game-container">
                <canvas id="gameCanvas"></canvas>
                <div class="scanlines"></div>
                
                <div id="ui-layer">
                    <!-- 시작 화면 -->
                    <div id="screen-start" class="screen-ui active">
                        <h1>RETRO<br>BREAKOUT</h1>
                        <div class="stats-container">
                            <div class="stat-item">
                                <span class="stat-label">HIGH SCORE</span>
                                <span id="start-highscore" class="stat-value highlight">0</span>
                            </div>
                        </div>
                        <button id="start-btn" class="blink">INSERT COIN</button>
                        <button id="view-ranking-btn" style="margin-top:5px; border:none; font-size:10px; color:#888;">VIEW RANKING</button>
                    </div>

                    <!-- 게임 오버 화면 -->
                    <div id="screen-gameover" class="screen-ui">
                        <h1>GAME OVER</h1>
                        <p>YOUR SCORE: <span id="go-score" class="highlight">0</span></p>
                        
                        <!-- 게임 오버 시 보여줄 미니 랭킹 -->
                        <div style="margin: 10px 0; width: 85%;">
                            <h2 style="font-size: 8px; color: #888; margin-bottom: 8px; letter-spacing: 2px;">- HALL OF FAME -</h2>
                            <div id="gameover-ranking-list" class="ranking-list-container" style="width: 100%;">
                                <!-- 랭킹 목록 -->
                            </div>
                        </div>

                        <button id="retry-btn">TRY AGAIN</button>
                        <button id="go-home-btn" style="margin-top:5px; border:none; font-size:10px; color:#888;">MAIN MENU</button>
                    </div>

                    <!-- 신기록(이니셜 입력) 화면 -->
                    <div id="screen-newrecord" class="screen-ui">
                        <h1 class="highlight">NEW RECORD!</h1>
                        <p>ENTER INITIALS</p>
                        <p>RANK: <span id="nr-rank">1</span></p>
                        <input type="text" id="initials-input" maxlength="3" autocomplete="off" placeholder="AAA">
                        <button id="submit-score-btn">OK</button>
                    </div>

                    <!-- 전체 랭킹 화면 -->
                    <div id="screen-ranking" class="screen-ui">
                        <h2>HALL OF FAME</h2>
                        <div id="ranking-list" class="ranking-list-container">
                            <!-- 랭킹 목록 -->
                        </div>
                        <button id="back-btn">BACK</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls-area">
            <div class="d-pad-container">
                <div class="d-pad">
                    <div class="d-pad-h"></div><div class="d-pad-v"></div><div class="d-pad-center"></div>
                    <div class="d-btn btn-up"></div><div class="d-btn btn-down"></div>
                    <div class="d-btn btn-left" id="btn-left"></div><div class="d-btn btn-right" id="btn-right"></div>
                </div>
            </div>
            <div class="action-buttons">
                <div class="abxy-btn btn-x">X</div><div class="abxy-btn btn-y">Y</div>
                <div class="abxy-btn btn-b" id="btn-b">B</div><div class="abxy-btn btn-a" id="btn-a">A</div>
            </div>
            <div class="center-buttons">
                <div class="fn-btn-group"><div class="fn-btn" id="btn-select"></div><span class="fn-label">Select</span></div>
                <div class="fn-btn-group"><div class="fn-btn" id="btn-start"></div><span class="fn-label">Start</span></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * 게임 설정 및 상수
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        
        // Screens
        const screenStart = document.getElementById('screen-start');
        const screenGameOver = document.getElementById('screen-gameover');
        const screenNewRecord = document.getElementById('screen-newrecord');
        const screenRanking = document.getElementById('screen-ranking');
        const allScreens = [screenStart, screenGameOver, screenNewRecord, screenRanking];

        // UI Elements
        const startHighScoreDisplay = document.getElementById('start-highscore');
        const goScoreDisplay = document.getElementById('go-score');
        const nrRankDisplay = document.getElementById('nr-rank');
        const initialsInput = document.getElementById('initials-input');
        
        // 랭킹 리스트 컨테이너들
        const rankingList = document.getElementById('ranking-list');
        const gameoverRankingList = document.getElementById('gameover-ranking-list');

        // Buttons
        const startBtn = document.getElementById('start-btn');
        const viewRankingBtn = document.getElementById('view-ranking-btn');
        const retryBtn = document.getElementById('retry-btn');
        const goHomeBtn = document.getElementById('go-home-btn'); // Renamed/New
        const submitScoreBtn = document.getElementById('submit-score-btn');
        const backBtn = document.getElementById('back-btn');

        // 로컬 스토리지 키
        const STORAGE_KEYS = {
            HIGH_SCORE: 'retroBreakout_highScore',
            RANKINGS: 'retroBreakout_rankings'
        };

        // 데이터 로드
        let highScore = parseInt(localStorage.getItem(STORAGE_KEYS.HIGH_SCORE)) || 0;
        let rankings = JSON.parse(localStorage.getItem(STORAGE_KEYS.RANKINGS)) || [
            { name: 'AAA', score: 2000 },
            { name: 'BBB', score: 1500 },
            { name: 'CCC', score: 1000 },
            { name: 'DDD', score: 500 },
            { name: 'EEE', score: 100 }
        ];

        startHighScoreDisplay.innerText = highScore;

        // 화면 전환 함수
        function showScreen(screen) {
            allScreens.forEach(s => s.classList.remove('active'));
            if(screen) screen.classList.add('active');
        }

        // 랭킹 표시 함수 (대상 컨테이너 지정 가능)
        function renderRankings(container) {
            container.innerHTML = '';
            rankings.sort((a, b) => b.score - a.score); // 점수 내림차순 정렬
            rankings.slice(0, 5).forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'rank-row';
                div.innerHTML = `
                    <span class="rank-rank">${index + 1}.</span>
                    <span class="rank-name">${item.name}</span>
                    <span class="rank-score">${item.score}</span>
                `;
                container.appendChild(div);
            });
        }

        // 캔버스 크기 설정
        let GAME_WIDTH = 600;
        let GAME_HEIGHT = 800;
        let scaleX = 1;
        let scaleY = 1;

        function resizeCanvas() {
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            scaleX = canvas.width / GAME_WIDTH;
            scaleY = canvas.height / GAME_HEIGHT;
        }
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        /**
         * 오디오 시스템
         */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'paddle') {
                osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'brick') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'wall') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'over') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'goodItem') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'badItem') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(150, now + 0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'laser') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'barrier') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'levelup') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            }
        }

        /**
         * 게임 객체 클래스
         */
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 4 + 2;
                this.speedX = Math.random() * 6 - 3; this.speedY = Math.random() * 6 - 3;
                this.life = 1.0; 
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.life -= 0.02; }
            draw(ctx) {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.size * scaleX, this.size * scaleX);
                ctx.globalAlpha = 1.0;
            }
        }

        class Item {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 24; this.height = 24; this.dy = 3;
                const types = ['wide', 'narrow', 'slow', 'fast', 'multi', 'barrier', 'giant', 'tiny', 'power', 'laser'];
                this.type = types[Math.floor(Math.random() * types.length)];
                switch(this.type) {
                    case 'wide': this.color = '#0f0'; this.symbol = 'W'; break;
                    case 'narrow': this.color = '#f00'; this.symbol = 'N'; break;
                    case 'slow': this.color = '#00f'; this.symbol = 'S'; break;
                    case 'fast': this.color = '#f90'; this.symbol = 'F'; break;
                    case 'multi': this.color = '#0ff'; this.symbol = 'M'; break;
                    case 'barrier': this.color = '#a0f'; this.symbol = 'B'; break;
                    case 'giant': this.color = '#f0f'; this.symbol = 'G'; break;
                    case 'tiny': this.color = '#800'; this.symbol = 'T'; break;
                    case 'power': this.color = '#ff0'; this.symbol = 'P'; break;
                    case 'laser': this.color = '#fff'; this.symbol = 'L'; break;
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
                ctx.fillStyle = '#fff'; ctx.font = `${12 * scaleX}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, (this.x + this.width/2) * scaleX, (this.y + this.height/2) * scaleY);
            }
            update() { this.y += this.dy; }
        }

        class Bullet {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 4; this.height = 10; this.dy = -10; this.active = true;
            }
            draw(ctx) { ctx.fillStyle = '#fff'; ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY); }
            update() { this.y += this.dy; if(this.y < 0) this.active = false; }
        }

        class Ball {
            constructor(x, y, dx, dy) {
                this.defaultRadius = 8; this.radius = this.defaultRadius;
                this.x = x || GAME_WIDTH / 2; this.y = y || GAME_HEIGHT - 50;
                const baseSpeed = 5 + (level - 1) * 0.5;
                this.dx = dx || baseSpeed * (Math.random() < 0.5 ? 1 : -1); this.dy = dy || -baseSpeed;
                this.active = (dx !== undefined); this.powerMode = false; 
            }
            reset() {
                this.x = paddle.x + paddle.width / 2; this.y = GAME_HEIGHT - 50;
                const baseSpeed = 5 + (level - 1) * 0.5;
                this.dx = baseSpeed * (Math.random() < 0.5 ? 1 : -1); this.dy = -baseSpeed;
                this.active = false; this.radius = this.defaultRadius; this.powerMode = false;
            }
            draw(ctx) {
                ctx.beginPath(); ctx.fillStyle = this.powerMode ? '#ff0' : '#fff';
                if (this.powerMode) { ctx.shadowBlur = 10; ctx.shadowColor = '#ff0'; }
                ctx.fillRect((this.x - this.radius) * scaleX, (this.y - this.radius) * scaleY, (this.radius * 2) * scaleX, (this.radius * 2) * scaleX);
                ctx.shadowBlur = 0; ctx.closePath();
            }
            update() {
                if (!this.active) { this.x = paddle.x + paddle.width / 2; this.y = paddle.y - this.radius - 1; return; }
                
                // 수평 속도 강제
                if (Math.abs(this.dx) < 2) {
                    let direction = this.dx === 0 ? (Math.random() < 0.5 ? 1 : -1) : (this.dx > 0 ? 1 : -1);
                    this.dx = direction * 2; 
                }

                this.x += this.dx; this.y += this.dy;
                if (this.x + this.radius > GAME_WIDTH || this.x - this.radius < 0) { this.dx = -this.dx; playSound('wall'); }
                if (this.y - this.radius < 0) { this.dy = -this.dy; playSound('wall'); }
            }
            changeSpeed(multiplier) {
                const currentSpeed = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
                const newSpeed = currentSpeed * multiplier;
                if (newSpeed < 3 || newSpeed > 12 + level) return;
                const ratio = newSpeed / currentSpeed; this.dx *= ratio; this.dy *= ratio;
            }
        }

        class Paddle {
            constructor() {
                this.defaultWidth = Math.max(100 - (level - 1) * 5, 60); this.width = this.defaultWidth;
                this.height = 15; this.x = GAME_WIDTH / 2 - this.width / 2; this.y = GAME_HEIGHT - 40;
                this.speed = 8; this.dx = 0; this.laserActive = false; this.laserTimer = 0;
            }
            draw(ctx) {
                ctx.fillStyle = this.laserActive ? '#f0f' : '#0ff'; ctx.shadowBlur = 10; ctx.shadowColor = this.laserActive ? '#f0f' : '#0ff';
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
                if(this.laserActive) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x * scaleX, this.y * scaleY, 5 * scaleX, -5 * scaleY);
                    ctx.fillRect((this.x + this.width - 5) * scaleX, this.y * scaleY, 5 * scaleX, -5 * scaleY);
                }
                ctx.shadowBlur = 0;
            }
            update() {
                this.x += this.dx;
                if (this.x < 0) this.x = 0; if (this.x + this.width > GAME_WIDTH) this.x = GAME_WIDTH - this.width;
                if(this.laserActive && gameRunning && ballStarted) {
                    this.laserTimer++;
                    if(this.laserTimer > 40) { 
                        bullets.push(new Bullet(this.x, this.y)); bullets.push(new Bullet(this.x + this.width - 5, this.y));
                        this.laserTimer = 0; playSound('laser');
                    }
                }
            }
            changeWidth(amount) { this.width += amount; if (this.width < 40) this.width = 40; if (this.width > 250) this.width = 250; }
        }

        class Brick {
            constructor(x, y, c) { this.x = x; this.y = y; this.c = c; this.width = 0; this.height = 25; this.status = 1; }
            draw(ctx) {
                if (this.status === 1) {
                    ctx.fillStyle = brickColors[this.c % brickColors.length];
                    ctx.fillRect((this.x + 2) * scaleX, (this.y + 2) * scaleY, (this.width - 4) * scaleX, (this.height - 4) * scaleY);
                }
            }
        }

        /**
         * 게임 상태 관리
         */
        let paddle; let balls = []; let bullets = []; let bricks = []; let particles = []; let items = [];
        let score = 0; let level = 1; 
        let gameRunning = false; let animationId; let ballStarted = false;
        let barrierActive = false; let levelUpMsgTimer = 0; 
        let rightPressed = false; let leftPressed = false;
        let brickColors = [];

        function getLevelColors(lvl) {
            const themes = [
                ['#f00', '#f90', '#ff0', '#0f0', '#00f', '#f0f'], 
                ['#0ff', '#00f', '#50f', '#a0f', '#fff', '#0aa'], 
                ['#f00', '#d00', '#f60', '#fa0', '#fff', '#800'], 
                ['#0f0', '#5f5', '#080', '#cfc', '#050', '#afa'], 
                ['#f0f', '#ff0', '#0ff', '#fff', '#f00', '#00f'], 
                ['#fff', '#aaa', '#555', '#222', '#f00', '#888']  
            ];
            if (lvl <= themes.length) return themes[lvl - 1];
            else {
                let randomTheme = []; let baseHue = Math.random() * 360;
                for(let i=0; i<6; i++) randomTheme.push(`hsl(${(baseHue + i * 40) % 360}, 100%, 50%)`);
                return randomTheme;
            }
        }

        function initBricks() {
            bricks = [];
            const rows = Math.min(6 + Math.floor((level - 1) / 2), 10);
            const cols = 8; const padding = 10; const offsetTop = 60; const offsetLeft = 35;
            const brickWidth = (GAME_WIDTH - (offsetLeft * 2)) / cols;
            for(let c=0; c<cols; c++) {
                for(let r=0; r<rows; r++) {
                    let b = new Brick(0, 0, r);
                    b.x = (c * brickWidth) + offsetLeft; b.y = (r * (b.height + padding)) + offsetTop; b.width = brickWidth;
                    bricks.push(b);
                }
            }
        }

        /* --- 컨트롤러 이벤트 매핑 --- */
        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);

        function keyDownHandler(e) {
            if(e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
            else if(e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
            else if((e.code === 'Space' || e.key === 'Enter')) {
                handleActionBtn();
            }
        }
        function keyUpHandler(e) {
            if(e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
            else if(e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
        }

        // 가상 버튼
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnA = document.getElementById('btn-a');
        const btnB = document.getElementById('btn-b');
        const btnStart = document.getElementById('btn-start');

        function bindBtn(btn, actionDown, actionUp) {
            btn.addEventListener('mousedown', (e) => { e.preventDefault(); actionDown(); });
            btn.addEventListener('mouseup', (e) => { e.preventDefault(); actionUp(); });
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); actionDown(); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); actionUp(); });
        }

        bindBtn(btnLeft, () => leftPressed = true, () => leftPressed = false);
        bindBtn(btnRight, () => rightPressed = true, () => rightPressed = false);
        
        function handleActionBtn() {
            if (screenStart.classList.contains('active')) {
                startGame();
            } else if (gameRunning && !ballStarted) {
                balls.forEach(b => b.active = true); ballStarted = true;
            } else if (screenGameOver.classList.contains('active')) {
                // 게임 오버 상태에선 버튼 누르면 재시작 (TRY AGAIN 버튼과 동일)
                startGame();
            } else if (screenRanking.classList.contains('active')) {
                showScreen(screenStart);
            }
        }

        bindBtn(btnA, handleActionBtn, () => {});
        bindBtn(btnB, handleActionBtn, () => {});
        bindBtn(btnStart, handleActionBtn, () => {});

        // 화면 UI 버튼 바인딩
        startBtn.addEventListener('click', startGame);
        viewRankingBtn.addEventListener('click', () => { renderRankings(rankingList); showScreen(screenRanking); });
        retryBtn.addEventListener('click', startGame);
        goHomeBtn.addEventListener('click', () => { showScreen(screenStart); });
        backBtn.addEventListener('click', () => { showScreen(screenStart); });
        
        // 랭킹 등록
        submitScoreBtn.addEventListener('click', () => {
            const initials = initialsInput.value.trim().toUpperCase() || 'AAA';
            rankings.push({ name: initials, score: score });
            rankings.sort((a, b) => b.score - a.score);
            rankings = rankings.slice(0, 5); // Top 5만 유지
            localStorage.setItem(STORAGE_KEYS.RANKINGS, JSON.stringify(rankings));
            
            // 등록 후 랭킹 화면으로 이동 (여기서도 랭킹 렌더링)
            renderRankings(rankingList);
            showScreen(screenRanking);
        });


        function spawnItem(x, y) { if (Math.random() < 0.25) items.push(new Item(x, y)); }

        function destroyBrick(b) {
            b.status = 0; score += 10; playSound('brick');
            for(let k=0; k<6; k++) particles.push(new Particle(b.x + b.width/2, b.y + b.height/2, brickColors[b.c % brickColors.length]));
            spawnItem(b.x + b.width/2 - 12, b.y);
        }

        function nextLevel() {
            level++; playSound('levelup');
            if(level > maxLevel) { maxLevel = level; } // 로컬스토리지는 게임오버시 저장
            brickColors = getLevelColors(level);
            balls = [new Ball()]; ballStarted = false; bullets = []; items = []; particles = []; barrierActive = false; paddle = new Paddle();
            initBricks(); levelUpMsgTimer = 120; 
        }

        function collisionDetection() {
            let activeBricks = bricks.filter(b => b.status === 1).length;
            if(activeBricks === 0) nextLevel(); 

            balls.forEach(ball => {
                if(!ball.active) return;
                for(let i=0; i<bricks.length; i++) {
                    let b = bricks[i];
                    if(b.status === 1) {
                        if(ball.x > b.x && ball.x < b.x + b.width && ball.y > b.y && ball.y < b.y + b.height) {
                            if (!ball.powerMode) ball.dy = -ball.dy;
                            destroyBrick(b);
                        }
                    }
                }
                if (ball.y + ball.radius >= paddle.y && ball.y - ball.radius <= paddle.y + paddle.height &&
                    ball.x >= paddle.x && ball.x <= paddle.x + paddle.width) {
                    if (ball.dy > 0) {
                        ball.dy = -ball.dy; const hitPoint = ball.x - (paddle.x + paddle.width / 2);
                        ball.dx = hitPoint * 0.15; if(Math.abs(ball.dx) < 2) ball.dx = (ball.dx < 0 ? -2 : 2);
                        playSound('paddle');
                    }
                }
                if (barrierActive && ball.y + ball.radius > GAME_HEIGHT - 10) {
                    ball.dy = -Math.abs(ball.dy); barrierActive = false; playSound('barrier');
                }
            });

            bullets.forEach(bullet => {
                if(!bullet.active) return;
                for(let i=0; i<bricks.length; i++) {
                    let b = bricks[i];
                    if(b.status === 1) {
                        if(bullet.x > b.x && bullet.x < b.x + b.width && bullet.y > b.y && bullet.y < b.y + b.height) {
                            bullet.active = false; destroyBrick(b); break; 
                        }
                    }
                }
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 캔버스 내 HUD (인게임) - 상단 바 스타일
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, 40 * scaleY);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, 40 * scaleY); ctx.lineTo(canvas.width, 40 * scaleY); ctx.stroke();
            
            ctx.fillStyle = '#fff'; ctx.font = `${14 * scaleX}px "Press Start 2P"`; ctx.textBaseline = 'middle';
            ctx.textAlign = 'left'; ctx.fillText(`SCORE:${score}`, 10 * scaleX, 20 * scaleY);
            ctx.textAlign = 'right'; ctx.fillText(`LVL:${level}`, GAME_WIDTH * scaleX - 10, 20 * scaleY);

            if(levelUpMsgTimer > 0) {
                ctx.fillStyle = `rgba(255, 255, 0, ${levelUpMsgTimer / 60})`; ctx.font = `${40 * scaleX}px "Press Start 2P"`;
                ctx.textAlign = 'center'; ctx.fillText(`LEVEL ${level}`, (GAME_WIDTH/2) * scaleX, (GAME_HEIGHT/2) * scaleY);
                levelUpMsgTimer--;
            }

            if(rightPressed) paddle.dx = paddle.speed; else if(leftPressed) paddle.dx = -paddle.speed; else paddle.dx = 0;
            paddle.update(); paddle.draw(ctx);
            
            for(let i = balls.length -1; i >= 0; i--) {
                let b = balls[i]; b.update(); b.draw(ctx);
                if(b.y - b.radius > GAME_HEIGHT) balls.splice(i, 1);
            }

            if(balls.length === 0 && gameRunning) gameOver();

            for(let i = bullets.length -1; i >= 0; i--) {
                bullets[i].update(); bullets[i].draw(ctx); if(!bullets[i].active) bullets.splice(i, 1);
            }
            bricks.forEach(brick => brick.draw(ctx));
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(); particles[i].draw(ctx); if (particles[i].life <= 0) particles.splice(i, 1);
            }
            if(barrierActive) {
                ctx.fillStyle = '#a0f'; ctx.globalAlpha = 0.5; ctx.fillRect(0, (GAME_HEIGHT - 10) * scaleY, GAME_WIDTH * scaleX, 10 * scaleY); ctx.globalAlpha = 1.0;
            }
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i]; item.update(); item.draw(ctx);
                if (item.y > GAME_HEIGHT) { items.splice(i, 1); continue; }
                if (item.x < paddle.x + paddle.width && item.x + item.width > paddle.x && item.y < paddle.y + paddle.height && item.y + item.height > paddle.y) {
                    applyItemEffect(item.type); items.splice(i, 1);
                }
            }
            collisionDetection();
            if(gameRunning) animationId = requestAnimationFrame(draw);
        }

        function applyItemEffect(type) {
            let isBad = (type === 'narrow' || type === 'fast' || type === 'tiny'); playSound(isBad ? 'badItem' : 'goodItem');
            switch(type) {
                case 'wide': paddle.changeWidth(30); break;
                case 'narrow': paddle.changeWidth(-30); break;
                case 'slow': balls.forEach(b => b.changeSpeed(0.8)); break;
                case 'fast': balls.forEach(b => b.changeSpeed(1.3)); break;
                case 'multi': 
                    let newBalls = []; balls.forEach(b => { newBalls.push(new Ball(b.x, b.y, b.dx - 2, b.dy)); newBalls.push(new Ball(b.x, b.y, b.dx + 2, b.dy)); });
                    balls = balls.concat(newBalls); break;
                case 'barrier': barrierActive = true; break;
                case 'giant': balls.forEach(b => b.radius = 16); break;
                case 'tiny': balls.forEach(b => b.radius = 4); break;
                case 'power': balls.forEach(b => b.powerMode = true); setTimeout(() => { balls.forEach(b => b.powerMode = false); }, 5000); break;
                case 'laser': paddle.laserActive = true; setTimeout(() => { paddle.laserActive = false; }, 8000); break;
            }
        }

        function startGame() {
            initAudio(); showScreen(null); // 모든 UI 숨김
            score = 0; level = 1; brickColors = getLevelColors(level);
            paddle = new Paddle(); balls = [new Ball()]; bullets = []; items = []; barrierActive = false;
            initBricks(); particles = []; ballStarted = false;
            gameRunning = true; resizeCanvas(); draw();
        }

        function gameOver() {
            gameRunning = false; cancelAnimationFrame(animationId); playSound('over');
            
            // 하이 스코어 갱신
            if (score > highScore) { highScore = score; localStorage.setItem(STORAGE_KEYS.HIGH_SCORE, highScore); }
            startHighScoreDisplay.innerText = highScore;

            // 랭킹 진입 여부 확인 (5위 점수보다 높으면)
            let lowestScore = rankings.length < 5 ? 0 : rankings[rankings.length - 1].score;
            
            if (score > lowestScore) {
                // 신기록 화면 표시
                nrRankDisplay.innerText = getPotentialRank(score);
                initialsInput.value = '';
                showScreen(screenNewRecord);
                initialsInput.focus();
            } else {
                // 일반 게임오버 화면 표시 (여기에 랭킹 추가됨)
                goScoreDisplay.innerText = score;
                // 게임 오버 화면 랭킹 렌더링
                renderRankings(gameoverRankingList);
                showScreen(screenGameOver);
            }
        }

        function getPotentialRank(score) {
            let tempRankings = [...rankings, { score: score }];
            tempRankings.sort((a, b) => b.score - a.score);
            return tempRankings.findIndex(r => r.score === score) + 1;
        }
    </script>
</body>
</html>
